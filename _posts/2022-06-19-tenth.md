---
layout: single
title:  "C++ 정리 8 (객체 배열,동적 메모리)"
---

## C++ 정리 8 (객체 배열, 동적 메모리)

오늘은 지난 시간에 이어서 객체 배열을 정리해보도록 하겠습니다.

**배열 소멸자**

배열에도 마찬가지로 소멸자가 존재합니다.

배열이 소멸되면 소멸자가 실행되고 모든 원소 객체마다 소멸자가 호출 됩니다. 이때 순서는 높은 인덱스부터 순서대로 원소 객체가 소멸됩니다.

### 객체 배열 초기화

그러면 객체의 배열은 어떻게 초기화 할 수 있을까요?

이것도 기존의 배열의 초기화와 유사합니다.

​		Cirle circleArray[3] = { Circle(10), Circle(20), Circle( ) };

이렇게 초기화 할 때마다 각 원소의 생성자가 호출된다.



## 동적메모리

오늘은 동적 메모리에 대해서 집중적으로 정리해보도록 하겠습니다.

지금까지 배운 배열은 크기가 정해져서 그 크기를 바꿀 수 없었습니다.

처음엔 불편함 없이 사용했지만 코딩을 계속 하다보니 크기가 고정된 배열을 사용하는 것은 많이 불편했습니다. 이것을 해결하기 위해서 동적 메모리 할당을 사용할 수 있습니다.

동적 메모리 할당을 사용하면 배열의 크기를 증가시킬 수도 있고 감소 시킬 수도 있습니다. 다음의 예시로 동적 메모리 할당을 어떻게 사용하는지 자세히 알아보도록 하겠습니다.

### new, delete 연산자

new 연산자는 데이터 타입의 크기만큼 힙으로부터 메모리를 할당받고 주소를 리턴합니다. 

delete 연산자는 포인터변수가 가르키는 메모리를 힙으로 반환 합니다.

​		int *pInt = new int;

​		*pInt = 5;   //할당 받은 정수 공간에 5를 기록합니다.

​		delete pInt;

**동적 할당 메모리 초기화**

다음과 같이 동적 메모리를 할당할때 초기화를 할 수 있습니다.

​		int *pInt = new int(20);

pint 포인터가 생성되는 동시에 20이라는 정수값으로 초기화 됩니다.

**주의**

다음과 같은 오류를 주의 하여야합니다.

​		int *p = new int;

​		delete p;

​		delete p;

한번 할당 받은 메모리를 2번 반환하므로 오류가 발생합니다. 이 예시만 보았을때는 누가 이런 실수를 해? 라고 생각하실 수 있지만, 나중에 포인터가 여러번 사용되는 객체 지향 프로그래밍을 작성 하실때는 이러한 포인터가 몇번 사용되었는지 모를 수 있으므로 여러번 반환되는 오류가 발생할 수 있습니다. 이 문제를 해결하기 위해서 방법이 있지만 다음에 복잡한 프로그래밍을 정리할 때 함께 정리하도록 하겠습니다.

**동적 할당을 이용해 배열 할당하기**

동적 할당을 사용하면 배열도 할당할 수 있습니다,

​		int *p = new int [5];

​		delete [] p;

이때 주의 할점은 할당 할때 배열의 크기를 정해주고 반환할때는 [] 연산자를 반드시 작성해주셔야 한다는 뜻입니다.

다음 시간에 이어서 객체의 동적 생성을 정리해보도록 하겠습니다.

